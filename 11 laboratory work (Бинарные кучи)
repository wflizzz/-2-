Main.cpp:

#include "Heap.h" 
#include <iostream> 
using namespace std;

// Функция сравнения для элементов типа AAA
heap::CMP cmpAAA(void* a1, void* a2)
{
    // Приводим указатели к типу AAA
#define A1 ((AAA*)a1)
#define A2 ((AAA*)a2)
    heap::CMP rc = heap::EQUAL; // Инициализируем результат сравнения как EQUAL (равно)
    if (A1->x > A2->x) // Если значение x первого элемента больше значения x второго элемента
        rc = heap::GREAT; // То результат сравнения будет GREAT (больше)
    else if (A2->x > A1->x) // Иначе если значение x второго элемента больше значения x первого элемента
        rc = heap::LESS; // То результат сравнения будет LESS (меньше)
    return rc; // Возвращаем результат сравнения
#undef A2 // Удаляем временное определение A2
#undef A1 // Удаляем временное определение A1
}

int main()
{
    setlocale(LC_ALL, "rus"); // Устанавливаем локаль для корректного отображения русского текста
    int k, choice; // Объявляем переменные для ввода данных и выбора действия
    heap::Heap h1 = heap::create(30, cmpAAA); // Создаем первую кучу с максимальным размером 30 и функцией сравнения cmpAAA
    heap::Heap h2 = heap::create(30, cmpAAA); // Создаем вторую кучу с максимальным размером 30 и функцией сравнения cmpAAA
    for (;;) // Бесконечный цикл для отображения меню и обработки выбора
    {
        cout << "1 - вывод первой кучи на экран" << endl; // Выводим пункт меню для отображения первой кучи
        cout << "2 - добавить элемент в первую кучу" << endl; // Выводим пункт меню для добавления элемента в первую кучу
        cout << "3 - удалить максимальный элемент из первой кучи" << endl; // Выводим пункт меню для удаления максимального элемента из первой кучи
        cout << "4 - удалить минимальный элемент из первой кучи" << endl; // Выводим пункт меню для удаления минимального элемента из первой кучи
        cout << "5 - удалить элемент по индексу из первой кучи" << endl; // Выводим пункт меню для удаления элемента по индексу из первой кучи
        cout << "6 - вывод второй кучи на экран" << endl; // Выводим пункт меню для отображения второй кучи
        cout << "7 - добавить элемент во вторую кучу" << endl; // Выводим пункт меню для добавления элемента во вторую кучу
        cout << "8 - удалить максимальный элемент из второй кучи" << endl; // Выводим пункт меню для удаления максимального элемента из второй кучи
        cout << "9 - удалить минимальный элемент из второй кучи" << endl; // Выводим пункт меню для удаления минимального элемента из второй кучи
        cout << "10 - удалить элемент по индексу из второй кучи" << endl; // Выводим пункт меню для удаления элемента по индексу из второй кучи
        cout << "11 - объединить кучи" << endl; // Выводим пункт меню для объединения кучей
        cout << "0 - выход" << endl; // Выводим пункт меню для выхода из программы
        cout << "сделайте выбор" << endl; // Просим пользователя выбрать пункт меню
        cin >> choice; // Считываем выбор пользователя
        switch (choice) // Выполняем соответствующее действие в зависимости от выбора
        {
        case 0: // Если выбран пункт выхода
            exit(0); // Завершаем программу
        case 1: // Если выбран пункт вывода первой кучи на экран
            h1.scan(0); // Вызываем функцию для отображения первой кучи
            break; // Завершаем выполнение блока case
        case 2: // Если выбран пункт добавления элемента в первую кучу
        {
            AAA* a = new AAA; // Выделяем память под новый элемент
            if (!a) {
                cout << "Ошибка выделения памяти!" << endl;
                break;
            }
            cout << "введите ключ для первой кучи" << endl; // Просим пользователя ввести ключ элемента
            cin >> k; // Считываем ключ
            a->x = k; // Присваиваем ключ элементу
            h1.insert(a); // Вставляем элемент в первую кучу
        }
        break; // Завершаем выполнение блока case
        case 3: // Если выбран пункт удаления максимального элемента из первой кучи
            h1.extractMax(); // Вызываем функцию для удаления максимального элемента из первой кучи
            break; // Завершаем выполнение блока case
        case 4: // Если выбран пункт удаления минимального элемента из первой кучи
            h1.extractMin(); // Вызываем функцию для удаления минимального элемента из первой кучи
            break; // Завершаем выполнение блока case
        case 5: // Если выбран пункт удаления элемента по индексу из первой кучи
        {
            int idx; // Объявляем переменную для индекса элемента
            cout << "Введите индекс элемента для удаления из первой кучи: "; // Просим пользователя ввести индекс элемента
            cin >> idx; // Считываем индекс
            if (idx >= 0 && idx < h1.size) {
                h1.extractI(idx); // Вызываем функцию для удаления элемента по указанному индексу из первой кучи
            }
            else {
                cout << "Некорректный индекс!" << endl;
            }
        }
        break; // Завершаем выполнение блока case
        case 6: // Если выбран пункт вывода второй кучи на экран
            h2.scan(0); // Вызываем функцию для отображения второй кучи
            break; // Завершаем выполнение блока case
        case 7: // Если выбран пункт добавления элемента во вторую кучу
        {
            AAA* a = new AAA; // Выделяем память под новый элемент
            if (!a) {
                cout << "Ошибка выделения памяти!" << endl;
                break;
            }
            cout << "введите ключ для второй кучи" << endl; // Просим пользователя ввести ключ элемента
            cin >> k; // Считываем ключ
            a->x = k; // Присваиваем ключ элементу
            h2.insert(a); // Вставляем элемент во вторую кучу
        }
        break; // Завершаем выполнение блока case
        case 8: // Если выбран пункт удаления максимального элемента из второй кучи
            h2.extractMax(); // Вызываем функцию для удаления максимального элемента из второй кучи
            break; // Завершаем выполнение блока case
        case 9: // Если выбран пункт удаления минимального элемента из второй кучи
            h2.extractMin(); // Вызываем функцию для удаления минимального элемента из второй кучи
            break; // Завершаем выполнение блока case
        case 10: // Если выбран пункт удаления элемента по индексу из второй кучи
        {
            int idx; // Объявляем переменную для индекса элемента
            cout << "Введите индекс элемента для удаления из второй кучи: "; // Просим пользователя ввести индекс элемента
            cin >> idx; // Считываем индекс
            if (idx >= 0 && idx < h2.size) {
                h2.extractI(idx); // Вызываем функцию для удаления элемента по указанному индексу из второй кучи
            }
            else {
                cout << "Некорректный индекс!" << endl;
            }
        }
        break; // Завершаем выполнение блока case
        case 11: // Если выбран пункт объединения кучей
        {
            if (&h1 == &h2) {
                cout << "Невозможно объединить кучи: они являются одной и той же кучей." << endl;
            }
            else {
                cout << "Объединение куч..." << endl; // Выводим сообщение о начале объединения
                h1.unionHeap(h2); // Вызываем функцию для объединения первой и второй куч
                cout << "Кучи объединены." << endl; // Выводим сообщение об успешном объединении
            }
        }
        break; // Завершаем выполнение блока case
        default: // Если выбрано некорректное действие
            cout << endl << "Введена неверная команда!" << endl; // Выводим сообщение о некорректном выборе
        }
    }
    return 0;
}

Heap.cpp:

#include "Heap.h" 
// Определение метода print структуры AAA для вывода значения x
void AAA::print()
{
    std::cout << x; // Выводим значение x на стандартный поток вывода
}

namespace heap // Определение пространства имен heap для организации кода в логические блоки
{
    // Определение функции create для создания кучи с заданным максимальным размером и функцией сравнения
    Heap create(int maxsize, CMP(*f)(void*, void*))
    {
        return *(new Heap(maxsize, f)); // Создаем новый объект кучи с заданными параметрами и возвращаем его
    }

    // Определение метода left для вычисления индекса левого потомка элемента в куче
    int Heap::left(int ix)
    {
        return (2 * ix + 1 >= size) ? -1 : (2 * ix + 1); // Вычисляем индекс левого потомка элемента и возвращаем его
    }

    // Определение метода right для вычисления индекса правого потомка элемента в куче
    int Heap::right(int ix)
    {
        return (2 * ix + 2 >= size) ? -1 : (2 * ix + 2); // Вычисляем индекс правого потомка элемента и возвращаем его
    }

    // Определение метода parent для вычисления индекса родительского элемента для заданного потомка
    int Heap::parent(int ix)
    {
        return (ix + 1) / 2 - 1; // Вычисляем индекс родительского элемента и возвращаем его
    }

    // Определение метода swap для обмена элементов местами
    void Heap::swap(int i, int j)
    {
        void* buf = storage[i]; // Сохраняем значение элемента на позиции i во временной переменной
        storage[i] = storage[j]; // Присваиваем элементу на позиции i значение элемента на позиции j
        storage[j] = buf; // Присваиваем элементу на позиции j сохраненное значение из временной переменной
    }

    // Определение метода heapify для поддержания свойств кучи
    void Heap::heapify(int ix)
    {
        int l = left(ix), r = right(ix), irl = ix; // Вычисляем индексы левого и правого потомков и индекс наибольшего элемента
        if (l > 0) // Проверяем, существует ли левый потомок
        {
            if (isGreat(storage[l], storage[ix])) irl = l; // Если левый потомок больше текущего элемента, обновляем индекс наибольшего элемента
            if (r > 0 && isGreat(storage[r], storage[irl])) irl = r; // Если правый потомок больше текущего элемента, обновляем индекс наибольшего элемента
            if (irl != ix) // Если индекс наибольшего элемента изменился
            {
                swap(ix, irl); // Обмениваем текущий элемент с наибольшим элементом
                heapify(irl); // Рекурсивно вызываем heapify для обновления кучи в поддереве
            }
        }
    }

    // Определение метода heapifyMin для поддержания свойств мин-кучи
    void Heap::heapifyMin(int ix)
    {
        int l = left(ix), r = right(ix), irl = ix; // Вычисляем индексы левого и правого потомков и индекс наименьшего элемента
        if (l > 0) // Проверяем, существует ли левый потомок
        {
            if (isLess(storage[l], storage[ix])) irl = l; // Если левый потомок меньше текущего элемента, обновляем индекс наименьшего элемента
            if (r > 0 && isLess(storage[r], storage[irl])) irl = r; // Если правый потомок меньше текущего элемента, обновляем индекс наименьшего элемента
            if (irl != ix) // Если индекс наименьшего элемента изменился
            {
                swap(ix, irl); // Обмениваем текущий элемент с наименьшим элементом
                heapifyMin(irl); // Рекурсивно вызываем heapifyMin для обновления кучи в поддереве
            }
        }
    }

    // Определение метода insert для вставки элемента в кучу
    void Heap::insert(void* x)
    {
        size_t i = size++; // Увеличиваем размер кучи и сохраняем его текущее значение
        if (!isFull()) // Проверяем, не является ли куча полной
        {
            storage[i] = x; // Вставляем элемент на позицию i в кучу
            while (i > 0 && isLess(storage[parent(i)], storage[i])) // Пока текущий элемент больше своего родителя
            {
                swap(parent(i), i); // Обмениваем текущий элемент с родителем
                i = parent(i); // Обновляем индекс текущего элемента
            }
        }
    }

    // Определение метода extractMax для удаления и возврата максимального элемента из кучи
    void* Heap::extractMax()
    {
        void* rc = nullptr; // Инициализируем переменную для хранения возвращаемого значения
        if (!isEmpty()) // Проверяем, не является ли куча пустой
        {
            rc = storage[0]; // Сохраняем максимальный элемент
            storage[0] = storage[--size]; // Заменяем корневой элемент последним элементом
            heapify(0); // Поддерживаем свойства кучи
        }
        return rc; // Возвращаем удаленный максимальный элемент
    }

    // Определение метода extractMin для удаления и возврата минимального элемента из кучи
    void* Heap::extractMin()
    {
        void* rc = nullptr; // Инициализируем переменную для хранения возвращаемого значения
        if (!isEmpty()) // Проверяем, не является ли куча пустой
        {
            rc = storage[0]; // Сохраняем минимальный элемент
            storage[0] = storage[--size]; // Заменяем корневой элемент последним элементом
            heapifyMin(0); // Поддерживаем свойства мин-кучи
        }
        return rc; // Возвращаем удаленный минимальный элемент
    }

    // Определение метода extractI для удаления и возврата элемента по указанному индексу из кучи
    void* Heap::extractI(int i)
    {
        void* rc = nullptr; // Инициализируем переменную для хранения возвращаемого значения
        if (!isEmpty() && i >= 0 && i < size) // Проверяем корректность указанного индекса
        {
            rc = storage[i]; // Сохраняем элемент на позиции i
            storage[i] = storage[--size]; // Заменяем элемент на позиции i последним элементом
            heapify(i); // Поддерживаем свойства кучи
        }
        return rc; // Возвращаем удаленный элемент
    }

    // Определение метода unionHeap для объединения текущей кучи с другой кучей
    void Heap::unionHeap(const Heap& other)
    {
        if (&other != this && size + other.size <= maxSize) // Проверяем, что кучи различны и их объединение не превысит максимальный размер
        {
            for (size_t i = 0; i < other.size; ++i) // Перебираем элементы другой кучи
            {
                storage[size + i] = other.storage[i]; // Добавляем элементы другой кучи в конец текущей кучи
            }
            size += other.size; // Обновляем размер текущей кучи
        }
        else
        {
            std::cerr << "Невозможно объединить кучи: превышение максимального размера." << std::endl; // Выводим сообщение об ошибке
        }
    }

    // Определение метода scan для вывода содержимого кучи
    void Heap::scan(int i) const
    {
        int probel = 20; // Инициализируем значение пробела для форматированного вывода
        std::cout << '\n'; // Выводим символ новой строки
        if (size == 0) // Проверяем, является ли куча пустой
            std::cout << "Куча пуста"; // Выводим сообщение о пустой куче
        for (size_t u = 0, y = 0; u < size; u++) // Перебираем элементы кучи
        {
            std::cout << std::setw(probel + 10) << std::setfill(' '); // Устанавливаем ширину поля и символ для заполнения
            ((AAA*)storage[u])->print(); // Выводим значение элемента на позиции u
            if (u == y) // Проверяем, достигли ли мы нового уровня в дереве
            {
                std::cout << '\n'; // Выводим символ новой строки
                if (y == 0) // Если уровень первый
                    y = 2; // Устанавливаем индекс следующего уровня
                else
                    y += y * 2; // Увеличиваем индекс следующего уровня вдвое
            }
            probel /= 2; // Уменьшаем значение пробела для следующего уровня
        }
        std::cout << '\n'; // Выводим символ новой строки в конце
    }
}
Heap.h:
#pragma once

#include <iostream> // Подключаем заголовочный файл для ввода-вывода через стандартные потоки
#include <iomanip> // Подключаем заголовочный файл для управления выводом через манипуляторы форматирования

struct AAA // Объявляем структуру AAA для хранения данных
{
    int x; // Поле для хранения целочисленного значения
    void print(); // Объявляем функцию print для вывода данных структуры
};

namespace heap // Объявляем пространство имен heap для организации кода в логические блоки
{
    enum CMP // Объявляем перечисление CMP для определения результатов сравнения элементов
    {
        LESS = -1, // Значение LESS указывает на то, что первый элемент меньше второго
        EQUAL = 0, // Значение EQUAL указывает на то, что оба элемента равны
        GREAT = 1 // Значение GREAT указывает на то, что первый элемент больше второго
    };

    struct Heap // Объявляем структуру Heap для реализации кучи
    {
        size_t size; // Поле для хранения текущего размера кучи
        size_t maxSize; // Поле для хранения максимального размера кучи
        void** storage; // Указатель на массив указателей, представляющих элементы кучи
        CMP(*compare)(void*, void*); // Указатель на функцию сравнения элементов кучи

        // Конструктор для инициализации полей структуры Heap
        Heap(int maxsize, CMP(*f)(void*, void*)) : size(0), maxSize(maxsize), storage(new void* [maxsize]), compare(f) {}

        // Функции для вычисления индексов дочерних и родительских элементов в куче
        int left(int ix); // Возвращает индекс левого потомка элемента
        int right(int ix); // Возвращает индекс правого потомка элемента
        int parent(int ix); // Возвращает индекс родительского элемента для заданного потомка

        // Функции для проверки состояния кучи
        bool isFull() const; // Проверяет, является ли куча полной
        bool isEmpty() const; // Проверяет, является ли куча пустой

        // Функции для сравнения элементов
        bool isLess(void* x1, void* x2) const; // Проверяет, меньше ли первый элемент второго
        bool isGreat(void* x1, void* x2) const; // Проверяет, больше ли первый элемент второго
        bool isEqual(void* x1, void* x2) const; // Проверяет, равны ли два элемента

        // Функция для обмена элементов местами
        void swap(int i, int j);

        // Функции для поддержания свойств кучи
        void heapify(int ix); // Преобразует поддерево с корнем в узле ix в кучу
        void heapifyMin(int ix); // Преобразует поддерево с корнем в узле ix в мин-кучу

        // Функции для операций с кучей
        void insert(void* x); // Вставляет элемент в кучу
        void* extractMax(); // Удаляет и возвращает максимальный элемент из кучи
        void* extractMin(); // Удаляет и возвращает минимальный элемент из кучи
        void* extractI(int i); // Удаляет и возвращает элемент по указанному индексу из кучи
        void unionHeap(const Heap& other); // Объединяет текущую кучу с другой кучей
        void scan(int i) const; // Выводит содержимое кучи, начиная с элемента с индексом i
    };

    // Функция для создания кучи с заданным максимальным размером и функцией сравнения
    Heap create(int maxsize, CMP(*f)(void*, void*));
}
